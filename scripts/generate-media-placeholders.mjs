import { spawnSync } from 'node:child_process';
import { promises as fs } from 'node:fs';
import os from 'node:os';
import path from 'node:path';
import { fileURLToPath } from 'node:url';

import { Jimp } from 'jimp';
import { rgbaToThumbHash } from 'thumbhash';

const __filename = fileURLToPath(import.meta.url);
const __dirname = path.dirname(__filename);
const PROJECT_DIR = path.resolve(__dirname, '..');

const PUBLIC_DIR = path.join(PROJECT_DIR, 'public');
const IMAGES_DIR = path.join(PUBLIC_DIR, 'images');
const VIDEOS_DIR = path.join(PUBLIC_DIR, 'videos');
const OUT_FILE = path.join(PROJECT_DIR, 'src', 'generated', 'mediaPlaceholders.ts');

const IMAGE_EXTS = new Set(['.jpg', '.jpeg', '.png', '.webp']);
const VIDEO_EXTS = new Set(['.mp4', '.webm']);

function toPublicSrc(filePath) {
  const rel = path.relative(PUBLIC_DIR, filePath);
  return '/' + rel.split(path.sep).join('/');
}

async function listFilesRecursive(dirPath) {
  const out = [];
  const entries = await fs.readdir(dirPath, { withFileTypes: true });
  for (const entry of entries) {
    const full = path.join(dirPath, entry.name);
    if (entry.isDirectory()) {
      out.push(...(await listFilesRecursive(full)));
    } else if (entry.isFile()) {
      out.push(full);
    }
  }
  return out;
}

function ensureDir(dirPath) {
  return fs.mkdir(dirPath, { recursive: true });
}

function runFfmpegExtractFirstFrame({ inputPath, outputPath }) {
  const args = [
    '-hide_banner',
    '-loglevel',
    'error',
    '-y',
    '-i',
    inputPath,
    '-frames:v',
    '1',
    outputPath,
  ];

  const result = spawnSync('ffmpeg', args, { stdio: 'inherit' });
  if (result.error) throw result.error;
  if (result.status !== 0) {
    throw new Error(`ffmpeg failed (exit ${result.status}) for ${inputPath}`);
  }
}

async function computeThumbHashFromImageFile(filePath) {
  const image = await Jimp.read(filePath);
  const originalW = image.bitmap.width;
  const originalH = image.bitmap.height;

  // ThumbHash works best on small inputs; downscale for speed and stability.
  const maxDim = 96;
  const scale = Math.min(1, maxDim / Math.max(originalW, originalH));
  const w = Math.max(1, Math.round(originalW * scale));
  const h = Math.max(1, Math.round(originalH * scale));

  // Jimp v1 supports object-form resize.
  image.resize({ w, h });

  const rgba = new Uint8Array(image.bitmap.data);
  const thumbhashBytes = rgbaToThumbHash(w, h, rgba);
  const thumbhash = Buffer.from(thumbhashBytes).toString('base64');

  return { w: originalW, h: originalH, thumbhash };
}

async function main() {
  const placeholders = {};

  const imageFiles = (await fs
    .stat(IMAGES_DIR)
    .then(() => listFilesRecursive(IMAGES_DIR))
    .catch(() => []))
    .filter((file) => IMAGE_EXTS.has(path.extname(file).toLowerCase()));

  const videoFiles = (await fs
    .stat(VIDEOS_DIR)
    .then(() => listFilesRecursive(VIDEOS_DIR))
    .catch(() => []))
    .filter((file) => VIDEO_EXTS.has(path.extname(file).toLowerCase()));

  for (const filePath of imageFiles) {
    const src = toPublicSrc(filePath);
    // eslint-disable-next-line no-console
    console.log(`placeholder:image ${src}`);
    try {
      placeholders[src] = await computeThumbHashFromImageFile(filePath);
    } catch (err) {
      // eslint-disable-next-line no-console
      console.warn(`placeholder:skip ${src}`);
      // eslint-disable-next-line no-console
      console.warn(err);
    }
  }

  const tmpDir = await fs.mkdtemp(path.join(os.tmpdir(), 'mukyala-placeholders-'));
  try {
    for (const filePath of videoFiles) {
      const src = toPublicSrc(filePath);
      // eslint-disable-next-line no-console
      console.log(`placeholder:video ${src}`);

      const framePath = path.join(
        tmpDir,
        path.basename(filePath).replace(/\W+/g, '_') + '.jpg',
      );
      try {
        runFfmpegExtractFirstFrame({ inputPath: filePath, outputPath: framePath });
        placeholders[src] = await computeThumbHashFromImageFile(framePath);
      } catch (err) {
        // eslint-disable-next-line no-console
        console.warn(`placeholder:skip ${src}`);
        // eslint-disable-next-line no-console
        console.warn(err);
      }
    }
  } finally {
    await fs.rm(tmpDir, { recursive: true, force: true });
  }

  const keys = Object.keys(placeholders).sort();
  const lines = [];
  lines.push('/* eslint-disable */');
  lines.push('// This file is generated by `scripts/generate-media-placeholders.mjs`.');
  lines.push('// Do not edit by hand.');
  lines.push('');
  lines.push('export type MediaPlaceholder = { w: number; h: number; thumbhash: string };');
  lines.push('');
  lines.push('export const MEDIA_PLACEHOLDERS: Record<string, MediaPlaceholder> = {');
  for (const key of keys) {
    const value = placeholders[key];
    lines.push(
      `  ${JSON.stringify(key)}: { w: ${value.w}, h: ${value.h}, thumbhash: ${JSON.stringify(
        value.thumbhash,
      )} },`,
    );
  }
  lines.push('};');
  lines.push('');
  lines.push(
    'export function getMediaPlaceholder(src: string): MediaPlaceholder | undefined {',
  );
  lines.push('  return MEDIA_PLACEHOLDERS[src];');
  lines.push('}');
  lines.push('');

  await ensureDir(path.dirname(OUT_FILE));
  await fs.writeFile(OUT_FILE, lines.join('\n'), 'utf8');
}

main().catch((err) => {
  // eslint-disable-next-line no-console
  console.error(err);
  process.exitCode = 1;
});
